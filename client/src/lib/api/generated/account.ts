/**
 * Generated by orval v8.5.1 üç∫
 * Do not edit manually.
 * online
 * OpenAPI spec version: v1
 */
import { createMutation, createQuery } from "@tanstack/svelte-query";
import type {
	CreateMutationOptions,
	CreateMutationResult,
	CreateQueryOptions,
	CreateQueryResult,
	DataTag,
	MutationFunction,
	QueryClient,
	QueryFunction,
	QueryKey,
} from "@tanstack/svelte-query";

import type {
	InternalErrorResponse,
	LoginGoogleParams,
	LoginRequest,
	PasskeyRequest,
	RefreshListResponse,
	RefreshRevokeRequest,
	UserModel,
	UserRegisterRequest,
} from "./api.schemas";

import { customInstance } from "../mutator/customInstance.svelte";
import type { ErrorType, BodyType } from "../mutator/customInstance.svelte";

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

export const getRegisterUrl = () => {
	return `/account/register`;
};

export const register = async (
	userRegisterRequest: UserRegisterRequest,
	options?: RequestInit
): Promise<void> => {
	return customInstance<void>(getRegisterUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(userRegisterRequest),
	});
};

export const getRegisterMutationOptions = <
	TError = ErrorType<InternalErrorResponse>,
	TContext = unknown,
>(options?: {
	mutation?: CreateMutationOptions<
		Awaited<ReturnType<typeof register>>,
		TError,
		{ data: BodyType<UserRegisterRequest> },
		TContext
	>;
	request?: SecondParameter<typeof customInstance>;
}): CreateMutationOptions<
	Awaited<ReturnType<typeof register>>,
	TError,
	{ data: BodyType<UserRegisterRequest> },
	TContext
> => {
	const mutationKey = ["register"];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof register>>,
		{ data: BodyType<UserRegisterRequest> }
	> = (props) => {
		const { data } = props ?? {};

		return register(data, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type RegisterMutationResult = NonNullable<Awaited<ReturnType<typeof register>>>;
export type RegisterMutationBody = BodyType<UserRegisterRequest>;
export type RegisterMutationError = ErrorType<InternalErrorResponse>;

export const createRegister = <TError = ErrorType<InternalErrorResponse>, TContext = unknown>(
	options?: () => {
		mutation?: CreateMutationOptions<
			Awaited<ReturnType<typeof register>>,
			TError,
			{ data: BodyType<UserRegisterRequest> },
			TContext
		>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: () => QueryClient
): CreateMutationResult<
	Awaited<ReturnType<typeof register>>,
	TError,
	{ data: BodyType<UserRegisterRequest> },
	TContext
> => {
	return createMutation(() => ({ ...getRegisterMutationOptions(options?.()) }), queryClient);
};
export const getRefreshUrl = () => {
	return `/account/refresh`;
};

export const refresh = async (options?: RequestInit): Promise<UserModel> => {
	return customInstance<UserModel>(getRefreshUrl(), {
		...options,
		method: "POST",
	});
};

export const getRefreshMutationOptions = <
	TError = ErrorType<InternalErrorResponse>,
	TContext = unknown,
>(options?: {
	mutation?: CreateMutationOptions<Awaited<ReturnType<typeof refresh>>, TError, void, TContext>;
	request?: SecondParameter<typeof customInstance>;
}): CreateMutationOptions<Awaited<ReturnType<typeof refresh>>, TError, void, TContext> => {
	const mutationKey = ["refresh"];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<Awaited<ReturnType<typeof refresh>>, void> = () => {
		return refresh(requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type RefreshMutationResult = NonNullable<Awaited<ReturnType<typeof refresh>>>;

export type RefreshMutationError = ErrorType<InternalErrorResponse>;

export const createRefresh = <TError = ErrorType<InternalErrorResponse>, TContext = unknown>(
	options?: () => {
		mutation?: CreateMutationOptions<Awaited<ReturnType<typeof refresh>>, TError, void, TContext>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: () => QueryClient
): CreateMutationResult<Awaited<ReturnType<typeof refresh>>, TError, void, TContext> => {
	return createMutation(() => ({ ...getRefreshMutationOptions(options?.()) }), queryClient);
};
export const getRefreshRevokeAllUrl = () => {
	return `/account/refresh/revokeAll`;
};

export const refreshRevokeAll = async (options?: RequestInit): Promise<void> => {
	return customInstance<void>(getRefreshRevokeAllUrl(), {
		...options,
		method: "POST",
	});
};

export const getRefreshRevokeAllMutationOptions = <
	TError = ErrorType<InternalErrorResponse>,
	TContext = unknown,
>(options?: {
	mutation?: CreateMutationOptions<
		Awaited<ReturnType<typeof refreshRevokeAll>>,
		TError,
		void,
		TContext
	>;
	request?: SecondParameter<typeof customInstance>;
}): CreateMutationOptions<Awaited<ReturnType<typeof refreshRevokeAll>>, TError, void, TContext> => {
	const mutationKey = ["refreshRevokeAll"];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<Awaited<ReturnType<typeof refreshRevokeAll>>, void> = () => {
		return refreshRevokeAll(requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type RefreshRevokeAllMutationResult = NonNullable<
	Awaited<ReturnType<typeof refreshRevokeAll>>
>;

export type RefreshRevokeAllMutationError = ErrorType<InternalErrorResponse>;

export const createRefreshRevokeAll = <
	TError = ErrorType<InternalErrorResponse>,
	TContext = unknown,
>(
	options?: () => {
		mutation?: CreateMutationOptions<
			Awaited<ReturnType<typeof refreshRevokeAll>>,
			TError,
			void,
			TContext
		>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: () => QueryClient
): CreateMutationResult<Awaited<ReturnType<typeof refreshRevokeAll>>, TError, void, TContext> => {
	return createMutation(
		() => ({ ...getRefreshRevokeAllMutationOptions(options?.()) }),
		queryClient
	);
};
export const getRefreshRevokeUrl = () => {
	return `/account/refresh/revoke`;
};

export const refreshRevoke = async (
	refreshRevokeRequest: RefreshRevokeRequest,
	options?: RequestInit
): Promise<void> => {
	return customInstance<void>(getRefreshRevokeUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(refreshRevokeRequest),
	});
};

export const getRefreshRevokeMutationOptions = <
	TError = ErrorType<InternalErrorResponse>,
	TContext = unknown,
>(options?: {
	mutation?: CreateMutationOptions<
		Awaited<ReturnType<typeof refreshRevoke>>,
		TError,
		{ data: BodyType<RefreshRevokeRequest> },
		TContext
	>;
	request?: SecondParameter<typeof customInstance>;
}): CreateMutationOptions<
	Awaited<ReturnType<typeof refreshRevoke>>,
	TError,
	{ data: BodyType<RefreshRevokeRequest> },
	TContext
> => {
	const mutationKey = ["refreshRevoke"];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof refreshRevoke>>,
		{ data: BodyType<RefreshRevokeRequest> }
	> = (props) => {
		const { data } = props ?? {};

		return refreshRevoke(data, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type RefreshRevokeMutationResult = NonNullable<Awaited<ReturnType<typeof refreshRevoke>>>;
export type RefreshRevokeMutationBody = BodyType<RefreshRevokeRequest>;
export type RefreshRevokeMutationError = ErrorType<InternalErrorResponse>;

export const createRefreshRevoke = <TError = ErrorType<InternalErrorResponse>, TContext = unknown>(
	options?: () => {
		mutation?: CreateMutationOptions<
			Awaited<ReturnType<typeof refreshRevoke>>,
			TError,
			{ data: BodyType<RefreshRevokeRequest> },
			TContext
		>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: () => QueryClient
): CreateMutationResult<
	Awaited<ReturnType<typeof refreshRevoke>>,
	TError,
	{ data: BodyType<RefreshRevokeRequest> },
	TContext
> => {
	return createMutation(() => ({ ...getRefreshRevokeMutationOptions(options?.()) }), queryClient);
};
export const getRefreshListUrl = () => {
	return `/account/refresh/list`;
};

export const refreshList = async (options?: RequestInit): Promise<RefreshListResponse[]> => {
	return customInstance<RefreshListResponse[]>(getRefreshListUrl(), {
		...options,
		method: "GET",
	});
};

export const getRefreshListQueryKey = () => {
	return [`/account/refresh/list`] as const;
};

export const getRefreshListQueryOptions = <
	TData = Awaited<ReturnType<typeof refreshList>>,
	TError = ErrorType<InternalErrorResponse>,
>(options?: {
	query?: Partial<CreateQueryOptions<Awaited<ReturnType<typeof refreshList>>, TError, TData>>;
	request?: SecondParameter<typeof customInstance>;
}) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getRefreshListQueryKey();

	const queryFn: QueryFunction<Awaited<ReturnType<typeof refreshList>>> = ({ signal }) =>
		refreshList({ signal, ...requestOptions });

	return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
		Awaited<ReturnType<typeof refreshList>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RefreshListQueryResult = NonNullable<Awaited<ReturnType<typeof refreshList>>>;
export type RefreshListQueryError = ErrorType<InternalErrorResponse>;

export function createRefreshList<
	TData = Awaited<ReturnType<typeof refreshList>>,
	TError = ErrorType<InternalErrorResponse>,
>(
	options?: () => {
		query?: Partial<CreateQueryOptions<Awaited<ReturnType<typeof refreshList>>, TError, TData>>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: () => QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
	const query = createQuery(
		() => getRefreshListQueryOptions(options?.()),
		queryClient
	) as CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

	return query;
}

export const getPasskeyUrl = () => {
	return `/account/passkey`;
};

export const passkey = async (
	passkeyRequest: PasskeyRequest,
	options?: RequestInit
): Promise<string> => {
	return customInstance<string>(getPasskeyUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(passkeyRequest),
	});
};

export const getPasskeyMutationOptions = <
	TError = ErrorType<InternalErrorResponse>,
	TContext = unknown,
>(options?: {
	mutation?: CreateMutationOptions<
		Awaited<ReturnType<typeof passkey>>,
		TError,
		{ data: BodyType<PasskeyRequest> },
		TContext
	>;
	request?: SecondParameter<typeof customInstance>;
}): CreateMutationOptions<
	Awaited<ReturnType<typeof passkey>>,
	TError,
	{ data: BodyType<PasskeyRequest> },
	TContext
> => {
	const mutationKey = ["passkey"];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof passkey>>,
		{ data: BodyType<PasskeyRequest> }
	> = (props) => {
		const { data } = props ?? {};

		return passkey(data, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type PasskeyMutationResult = NonNullable<Awaited<ReturnType<typeof passkey>>>;
export type PasskeyMutationBody = BodyType<PasskeyRequest>;
export type PasskeyMutationError = ErrorType<InternalErrorResponse>;

export const createPasskey = <TError = ErrorType<InternalErrorResponse>, TContext = unknown>(
	options?: () => {
		mutation?: CreateMutationOptions<
			Awaited<ReturnType<typeof passkey>>,
			TError,
			{ data: BodyType<PasskeyRequest> },
			TContext
		>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: () => QueryClient
): CreateMutationResult<
	Awaited<ReturnType<typeof passkey>>,
	TError,
	{ data: BodyType<PasskeyRequest> },
	TContext
> => {
	return createMutation(() => ({ ...getPasskeyMutationOptions(options?.()) }), queryClient);
};
export const getAccountMeUrl = () => {
	return `/account/me`;
};

export const accountMe = async (options?: RequestInit): Promise<UserModel> => {
	return customInstance<UserModel>(getAccountMeUrl(), {
		...options,
		method: "GET",
	});
};

export const getAccountMeQueryKey = () => {
	return [`/account/me`] as const;
};

export const getAccountMeQueryOptions = <
	TData = Awaited<ReturnType<typeof accountMe>>,
	TError = ErrorType<void | InternalErrorResponse>,
>(options?: {
	query?: Partial<CreateQueryOptions<Awaited<ReturnType<typeof accountMe>>, TError, TData>>;
	request?: SecondParameter<typeof customInstance>;
}) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getAccountMeQueryKey();

	const queryFn: QueryFunction<Awaited<ReturnType<typeof accountMe>>> = ({ signal }) =>
		accountMe({ signal, ...requestOptions });

	return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
		Awaited<ReturnType<typeof accountMe>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AccountMeQueryResult = NonNullable<Awaited<ReturnType<typeof accountMe>>>;
export type AccountMeQueryError = ErrorType<void | InternalErrorResponse>;

export function createAccountMe<
	TData = Awaited<ReturnType<typeof accountMe>>,
	TError = ErrorType<void | InternalErrorResponse>,
>(
	options?: () => {
		query?: Partial<CreateQueryOptions<Awaited<ReturnType<typeof accountMe>>, TError, TData>>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: () => QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
	const query = createQuery(
		() => getAccountMeQueryOptions(options?.()),
		queryClient
	) as CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

	return query;
}

export const getLogoutUrl = () => {
	return `/account/logout`;
};

export const logout = async (options?: RequestInit): Promise<boolean> => {
	return customInstance<boolean>(getLogoutUrl(), {
		...options,
		method: "POST",
	});
};

export const getLogoutMutationOptions = <
	TError = ErrorType<InternalErrorResponse>,
	TContext = unknown,
>(options?: {
	mutation?: CreateMutationOptions<Awaited<ReturnType<typeof logout>>, TError, void, TContext>;
	request?: SecondParameter<typeof customInstance>;
}): CreateMutationOptions<Awaited<ReturnType<typeof logout>>, TError, void, TContext> => {
	const mutationKey = ["logout"];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<Awaited<ReturnType<typeof logout>>, void> = () => {
		return logout(requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type LogoutMutationResult = NonNullable<Awaited<ReturnType<typeof logout>>>;

export type LogoutMutationError = ErrorType<InternalErrorResponse>;

export const createLogout = <TError = ErrorType<InternalErrorResponse>, TContext = unknown>(
	options?: () => {
		mutation?: CreateMutationOptions<Awaited<ReturnType<typeof logout>>, TError, void, TContext>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: () => QueryClient
): CreateMutationResult<Awaited<ReturnType<typeof logout>>, TError, void, TContext> => {
	return createMutation(() => ({ ...getLogoutMutationOptions(options?.()) }), queryClient);
};
export const getLoginUrl = () => {
	return `/account/login`;
};

export const login = async (
	loginRequest: LoginRequest,
	options?: RequestInit
): Promise<boolean> => {
	return customInstance<boolean>(getLoginUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(loginRequest),
	});
};

export const getLoginMutationOptions = <
	TError = ErrorType<InternalErrorResponse>,
	TContext = unknown,
>(options?: {
	mutation?: CreateMutationOptions<
		Awaited<ReturnType<typeof login>>,
		TError,
		{ data: BodyType<LoginRequest> },
		TContext
	>;
	request?: SecondParameter<typeof customInstance>;
}): CreateMutationOptions<
	Awaited<ReturnType<typeof login>>,
	TError,
	{ data: BodyType<LoginRequest> },
	TContext
> => {
	const mutationKey = ["login"];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof login>>,
		{ data: BodyType<LoginRequest> }
	> = (props) => {
		const { data } = props ?? {};

		return login(data, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type LoginMutationResult = NonNullable<Awaited<ReturnType<typeof login>>>;
export type LoginMutationBody = BodyType<LoginRequest>;
export type LoginMutationError = ErrorType<InternalErrorResponse>;

export const createLogin = <TError = ErrorType<InternalErrorResponse>, TContext = unknown>(
	options?: () => {
		mutation?: CreateMutationOptions<
			Awaited<ReturnType<typeof login>>,
			TError,
			{ data: BodyType<LoginRequest> },
			TContext
		>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: () => QueryClient
): CreateMutationResult<
	Awaited<ReturnType<typeof login>>,
	TError,
	{ data: BodyType<LoginRequest> },
	TContext
> => {
	return createMutation(() => ({ ...getLoginMutationOptions(options?.()) }), queryClient);
};
export const getLoginGoogleUrl = (params: LoginGoogleParams) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `/account/login/google?${stringifiedParams}`
		: `/account/login/google`;
};

export const loginGoogle = async (
	params: LoginGoogleParams,
	options?: RequestInit
): Promise<void> => {
	return customInstance<void>(getLoginGoogleUrl(params), {
		...options,
		method: "GET",
	});
};

export const getLoginGoogleQueryKey = (params?: LoginGoogleParams) => {
	return [`/account/login/google`, ...(params ? [params] : [])] as const;
};

export const getLoginGoogleQueryOptions = <
	TData = Awaited<ReturnType<typeof loginGoogle>>,
	TError = ErrorType<InternalErrorResponse>,
>(
	params: LoginGoogleParams,
	options?: {
		query?: Partial<CreateQueryOptions<Awaited<ReturnType<typeof loginGoogle>>, TError, TData>>;
		request?: SecondParameter<typeof customInstance>;
	}
) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getLoginGoogleQueryKey(params);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof loginGoogle>>> = ({ signal }) =>
		loginGoogle(params, { signal, ...requestOptions });

	return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
		Awaited<ReturnType<typeof loginGoogle>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LoginGoogleQueryResult = NonNullable<Awaited<ReturnType<typeof loginGoogle>>>;
export type LoginGoogleQueryError = ErrorType<InternalErrorResponse>;

export function createLoginGoogle<
	TData = Awaited<ReturnType<typeof loginGoogle>>,
	TError = ErrorType<InternalErrorResponse>,
>(
	params: () => LoginGoogleParams,
	options?: () => {
		query?: Partial<CreateQueryOptions<Awaited<ReturnType<typeof loginGoogle>>, TError, TData>>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: () => QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
	const query = createQuery(
		() => getLoginGoogleQueryOptions(params(), options?.()),
		queryClient
	) as CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

	return query;
}
