/**
 * Generated by orval v8.2.0 üç∫
 * Do not edit manually.
 * online
 * OpenAPI spec version: v1
 */
import { createMutation, createQuery } from "@tanstack/svelte-query";
import type {
	CreateMutationOptions,
	CreateMutationResult,
	CreateQueryOptions,
	CreateQueryResult,
	DataTag,
	MutationFunction,
	QueryClient,
	QueryFunction,
	QueryKey,
} from "@tanstack/svelte-query";

import type {
	InternalErrorResponse,
	LoginRequest,
	OnlineFeaturesAccountLoginGoogleEndpointParams,
	Request,
	UserModel,
	UserRegisterRequest,
} from "./api.schemas";

import { customInstance } from "../mutator/customInstance.svelte";
import type { ErrorType, BodyType } from "../mutator/customInstance.svelte";

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

export const getRegisterUrl = () => {
	return `/account/register`;
};

export const register = async (
	userRegisterRequest: UserRegisterRequest,
	options?: RequestInit
): Promise<void> => {
	return customInstance<void>(getRegisterUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(userRegisterRequest),
	});
};

export const getRegisterMutationOptions = <
	TError = ErrorType<InternalErrorResponse>,
	TContext = unknown,
>(options?: {
	mutation?: CreateMutationOptions<
		Awaited<ReturnType<typeof register>>,
		TError,
		{ data: BodyType<UserRegisterRequest> },
		TContext
	>;
	request?: SecondParameter<typeof customInstance>;
}): CreateMutationOptions<
	Awaited<ReturnType<typeof register>>,
	TError,
	{ data: BodyType<UserRegisterRequest> },
	TContext
> => {
	const mutationKey = ["register"];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof register>>,
		{ data: BodyType<UserRegisterRequest> }
	> = (props) => {
		const { data } = props ?? {};

		return register(data, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type RegisterMutationResult = NonNullable<Awaited<ReturnType<typeof register>>>;
export type RegisterMutationBody = BodyType<UserRegisterRequest>;
export type RegisterMutationError = ErrorType<InternalErrorResponse>;

export const createRegister = <TError = ErrorType<InternalErrorResponse>, TContext = unknown>(
	options?: () => {
		mutation?: CreateMutationOptions<
			Awaited<ReturnType<typeof register>>,
			TError,
			{ data: BodyType<UserRegisterRequest> },
			TContext
		>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: () => QueryClient
): CreateMutationResult<
	Awaited<ReturnType<typeof register>>,
	TError,
	{ data: BodyType<UserRegisterRequest> },
	TContext
> => {
	return createMutation(() => ({ ...getRegisterMutationOptions(options?.()) }), queryClient);
};
export const getRefreshUrl = () => {
	return `/account/refresh`;
};

export const refresh = async (options?: RequestInit): Promise<UserModel> => {
	return customInstance<UserModel>(getRefreshUrl(), {
		...options,
		method: "POST",
	});
};

export const getRefreshMutationOptions = <
	TError = ErrorType<InternalErrorResponse>,
	TContext = unknown,
>(options?: {
	mutation?: CreateMutationOptions<Awaited<ReturnType<typeof refresh>>, TError, void, TContext>;
	request?: SecondParameter<typeof customInstance>;
}): CreateMutationOptions<Awaited<ReturnType<typeof refresh>>, TError, void, TContext> => {
	const mutationKey = ["refresh"];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<Awaited<ReturnType<typeof refresh>>, void> = () => {
		return refresh(requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type RefreshMutationResult = NonNullable<Awaited<ReturnType<typeof refresh>>>;

export type RefreshMutationError = ErrorType<InternalErrorResponse>;

export const createRefresh = <TError = ErrorType<InternalErrorResponse>, TContext = unknown>(
	options?: () => {
		mutation?: CreateMutationOptions<Awaited<ReturnType<typeof refresh>>, TError, void, TContext>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: () => QueryClient
): CreateMutationResult<Awaited<ReturnType<typeof refresh>>, TError, void, TContext> => {
	return createMutation(() => ({ ...getRefreshMutationOptions(options?.()) }), queryClient);
};
export const getPasskeyUrl = () => {
	return `/account/passkey`;
};

export const passkey = async (request: Request, options?: RequestInit): Promise<string> => {
	return customInstance<string>(getPasskeyUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(request),
	});
};

export const getPasskeyMutationOptions = <
	TError = ErrorType<InternalErrorResponse>,
	TContext = unknown,
>(options?: {
	mutation?: CreateMutationOptions<
		Awaited<ReturnType<typeof passkey>>,
		TError,
		{ data: BodyType<Request> },
		TContext
	>;
	request?: SecondParameter<typeof customInstance>;
}): CreateMutationOptions<
	Awaited<ReturnType<typeof passkey>>,
	TError,
	{ data: BodyType<Request> },
	TContext
> => {
	const mutationKey = ["passkey"];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof passkey>>,
		{ data: BodyType<Request> }
	> = (props) => {
		const { data } = props ?? {};

		return passkey(data, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type PasskeyMutationResult = NonNullable<Awaited<ReturnType<typeof passkey>>>;
export type PasskeyMutationBody = BodyType<Request>;
export type PasskeyMutationError = ErrorType<InternalErrorResponse>;

export const createPasskey = <TError = ErrorType<InternalErrorResponse>, TContext = unknown>(
	options?: () => {
		mutation?: CreateMutationOptions<
			Awaited<ReturnType<typeof passkey>>,
			TError,
			{ data: BodyType<Request> },
			TContext
		>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: () => QueryClient
): CreateMutationResult<
	Awaited<ReturnType<typeof passkey>>,
	TError,
	{ data: BodyType<Request> },
	TContext
> => {
	return createMutation(() => ({ ...getPasskeyMutationOptions(options?.()) }), queryClient);
};
export const getAccountMeUrl = () => {
	return `/account/me`;
};

export const accountMe = async (options?: RequestInit): Promise<UserModel> => {
	return customInstance<UserModel>(getAccountMeUrl(), {
		...options,
		method: "GET",
	});
};

export const getAccountMeQueryKey = () => {
	return [`/account/me`] as const;
};

export const getAccountMeQueryOptions = <
	TData = Awaited<ReturnType<typeof accountMe>>,
	TError = ErrorType<void | InternalErrorResponse>,
>(options?: {
	query?: Partial<CreateQueryOptions<Awaited<ReturnType<typeof accountMe>>, TError, TData>>;
	request?: SecondParameter<typeof customInstance>;
}) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getAccountMeQueryKey();

	const queryFn: QueryFunction<Awaited<ReturnType<typeof accountMe>>> = () =>
		accountMe(requestOptions);

	return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
		Awaited<ReturnType<typeof accountMe>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AccountMeQueryResult = NonNullable<Awaited<ReturnType<typeof accountMe>>>;
export type AccountMeQueryError = ErrorType<void | InternalErrorResponse>;

export function createAccountMe<
	TData = Awaited<ReturnType<typeof accountMe>>,
	TError = ErrorType<void | InternalErrorResponse>,
>(
	options?: () => {
		query?: Partial<CreateQueryOptions<Awaited<ReturnType<typeof accountMe>>, TError, TData>>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: () => QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
	const query = createQuery(
		() => getAccountMeQueryOptions(options?.()),
		queryClient
	) as CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

	return query;
}

export const getLogoutUrl = () => {
	return `/account/logout`;
};

export const logout = async (options?: RequestInit): Promise<boolean> => {
	return customInstance<boolean>(getLogoutUrl(), {
		...options,
		method: "POST",
	});
};

export const getLogoutMutationOptions = <
	TError = ErrorType<InternalErrorResponse>,
	TContext = unknown,
>(options?: {
	mutation?: CreateMutationOptions<Awaited<ReturnType<typeof logout>>, TError, void, TContext>;
	request?: SecondParameter<typeof customInstance>;
}): CreateMutationOptions<Awaited<ReturnType<typeof logout>>, TError, void, TContext> => {
	const mutationKey = ["logout"];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<Awaited<ReturnType<typeof logout>>, void> = () => {
		return logout(requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type LogoutMutationResult = NonNullable<Awaited<ReturnType<typeof logout>>>;

export type LogoutMutationError = ErrorType<InternalErrorResponse>;

export const createLogout = <TError = ErrorType<InternalErrorResponse>, TContext = unknown>(
	options?: () => {
		mutation?: CreateMutationOptions<Awaited<ReturnType<typeof logout>>, TError, void, TContext>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: () => QueryClient
): CreateMutationResult<Awaited<ReturnType<typeof logout>>, TError, void, TContext> => {
	return createMutation(() => ({ ...getLogoutMutationOptions(options?.()) }), queryClient);
};
export const getLoginUrl = () => {
	return `/account/login`;
};

export const login = async (
	loginRequest: LoginRequest,
	options?: RequestInit
): Promise<boolean> => {
	return customInstance<boolean>(getLoginUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(loginRequest),
	});
};

export const getLoginMutationOptions = <
	TError = ErrorType<InternalErrorResponse>,
	TContext = unknown,
>(options?: {
	mutation?: CreateMutationOptions<
		Awaited<ReturnType<typeof login>>,
		TError,
		{ data: BodyType<LoginRequest> },
		TContext
	>;
	request?: SecondParameter<typeof customInstance>;
}): CreateMutationOptions<
	Awaited<ReturnType<typeof login>>,
	TError,
	{ data: BodyType<LoginRequest> },
	TContext
> => {
	const mutationKey = ["login"];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof login>>,
		{ data: BodyType<LoginRequest> }
	> = (props) => {
		const { data } = props ?? {};

		return login(data, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type LoginMutationResult = NonNullable<Awaited<ReturnType<typeof login>>>;
export type LoginMutationBody = BodyType<LoginRequest>;
export type LoginMutationError = ErrorType<InternalErrorResponse>;

export const createLogin = <TError = ErrorType<InternalErrorResponse>, TContext = unknown>(
	options?: () => {
		mutation?: CreateMutationOptions<
			Awaited<ReturnType<typeof login>>,
			TError,
			{ data: BodyType<LoginRequest> },
			TContext
		>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: () => QueryClient
): CreateMutationResult<
	Awaited<ReturnType<typeof login>>,
	TError,
	{ data: BodyType<LoginRequest> },
	TContext
> => {
	return createMutation(() => ({ ...getLoginMutationOptions(options?.()) }), queryClient);
};
export const getOnlineFeaturesAccountLoginGoogleEndpointUrl = (
	params: OnlineFeaturesAccountLoginGoogleEndpointParams
) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `/account/login/google?${stringifiedParams}`
		: `/account/login/google`;
};

export const onlineFeaturesAccountLoginGoogleEndpoint = async (
	params: OnlineFeaturesAccountLoginGoogleEndpointParams,
	options?: RequestInit
): Promise<void> => {
	return customInstance<void>(getOnlineFeaturesAccountLoginGoogleEndpointUrl(params), {
		...options,
		method: "GET",
	});
};

export const getOnlineFeaturesAccountLoginGoogleEndpointQueryKey = (
	params?: OnlineFeaturesAccountLoginGoogleEndpointParams
) => {
	return [`/account/login/google`, ...(params ? [params] : [])] as const;
};

export const getOnlineFeaturesAccountLoginGoogleEndpointQueryOptions = <
	TData = Awaited<ReturnType<typeof onlineFeaturesAccountLoginGoogleEndpoint>>,
	TError = ErrorType<InternalErrorResponse>,
>(
	params: OnlineFeaturesAccountLoginGoogleEndpointParams,
	options?: {
		query?: Partial<
			CreateQueryOptions<
				Awaited<ReturnType<typeof onlineFeaturesAccountLoginGoogleEndpoint>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof customInstance>;
	}
) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getOnlineFeaturesAccountLoginGoogleEndpointQueryKey(params);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof onlineFeaturesAccountLoginGoogleEndpoint>>
	> = () => onlineFeaturesAccountLoginGoogleEndpoint(params, requestOptions);

	return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
		Awaited<ReturnType<typeof onlineFeaturesAccountLoginGoogleEndpoint>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type OnlineFeaturesAccountLoginGoogleEndpointQueryResult = NonNullable<
	Awaited<ReturnType<typeof onlineFeaturesAccountLoginGoogleEndpoint>>
>;
export type OnlineFeaturesAccountLoginGoogleEndpointQueryError = ErrorType<InternalErrorResponse>;

export function createOnlineFeaturesAccountLoginGoogleEndpoint<
	TData = Awaited<ReturnType<typeof onlineFeaturesAccountLoginGoogleEndpoint>>,
	TError = ErrorType<InternalErrorResponse>,
>(
	params: () => OnlineFeaturesAccountLoginGoogleEndpointParams,
	options?: () => {
		query?: Partial<
			CreateQueryOptions<
				Awaited<ReturnType<typeof onlineFeaturesAccountLoginGoogleEndpoint>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: () => QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
	const query = createQuery(
		() => getOnlineFeaturesAccountLoginGoogleEndpointQueryOptions(params(), options?.()),
		queryClient
	) as CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

	return query;
}
