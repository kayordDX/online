/**
 * Generated by orval v8.2.0 ðŸº
 * Do not edit manually.
 * online
 * OpenAPI spec version: v1
 */
import { createMutation, createQuery } from "@tanstack/svelte-query";
import type {
	CreateMutationOptions,
	CreateMutationResult,
	CreateQueryOptions,
	CreateQueryResult,
	DataTag,
	MutationFunction,
	QueryClient,
	QueryFunction,
	QueryKey,
} from "@tanstack/svelte-query";

import type {
	InternalErrorResponse,
	LoginRequest,
	OnlineFeaturesAccountLoginGoogleEndpointParams,
	Request,
	UserModel,
	UserRegisterRequest,
} from "./api.schemas";

import { customInstance } from "../mutator/customInstance.svelte";
import type { ErrorType, BodyType } from "../mutator/customInstance.svelte";

export type registerResponse204 = {
	data: void;
	status: 204;
};

export type registerResponse500 = {
	data: InternalErrorResponse;
	status: 500;
};

export type registerResponseSuccess = registerResponse204 & {
	headers: Headers;
};
export type registerResponseError = registerResponse500 & {
	headers: Headers;
};

export type registerResponse = registerResponseSuccess | registerResponseError;

export const getRegisterUrl = () => {
	return `/account/register`;
};

export const register = async (
	userRegisterRequest: UserRegisterRequest,
	options?: RequestInit
): Promise<registerResponse> => {
	return customInstance<registerResponse>(getRegisterUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(userRegisterRequest),
	});
};

export const getRegisterMutationOptions = <
	TError = ErrorType<InternalErrorResponse>,
	TContext = unknown,
>(options?: {
	mutation?: CreateMutationOptions<
		Awaited<ReturnType<typeof register>>,
		TError,
		{ data: BodyType<UserRegisterRequest> },
		TContext
	>;
}): CreateMutationOptions<
	Awaited<ReturnType<typeof register>>,
	TError,
	{ data: BodyType<UserRegisterRequest> },
	TContext
> => {
	const mutationKey = ["register"];
	const { mutation: mutationOptions } = options
		? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey } };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof register>>,
		{ data: BodyType<UserRegisterRequest> }
	> = (props) => {
		const { data } = props ?? {};

		return register(data);
	};

	return { mutationFn, ...mutationOptions };
};

export type RegisterMutationResult = NonNullable<Awaited<ReturnType<typeof register>>>;
export type RegisterMutationBody = BodyType<UserRegisterRequest>;
export type RegisterMutationError = ErrorType<InternalErrorResponse>;

export const createRegister = <TError = ErrorType<InternalErrorResponse>, TContext = unknown>(
	options?: () => {
		mutation?: CreateMutationOptions<
			Awaited<ReturnType<typeof register>>,
			TError,
			{ data: BodyType<UserRegisterRequest> },
			TContext
		>;
	},
	queryClient?: () => QueryClient
): CreateMutationResult<
	Awaited<ReturnType<typeof register>>,
	TError,
	{ data: BodyType<UserRegisterRequest> },
	TContext
> => {
	return createMutation(() => ({ ...getRegisterMutationOptions(options?.()) }), queryClient);
};
export type refreshResponse200 = {
	data: UserModel;
	status: 200;
};

export type refreshResponse500 = {
	data: InternalErrorResponse;
	status: 500;
};

export type refreshResponseSuccess = refreshResponse200 & {
	headers: Headers;
};
export type refreshResponseError = refreshResponse500 & {
	headers: Headers;
};

export type refreshResponse = refreshResponseSuccess | refreshResponseError;

export const getRefreshUrl = () => {
	return `/account/refresh`;
};

export const refresh = async (options?: RequestInit): Promise<refreshResponse> => {
	return customInstance<refreshResponse>(getRefreshUrl(), {
		...options,
		method: "POST",
	});
};

export const getRefreshMutationOptions = <
	TError = ErrorType<InternalErrorResponse>,
	TContext = unknown,
>(options?: {
	mutation?: CreateMutationOptions<Awaited<ReturnType<typeof refresh>>, TError, void, TContext>;
}): CreateMutationOptions<Awaited<ReturnType<typeof refresh>>, TError, void, TContext> => {
	const mutationKey = ["refresh"];
	const { mutation: mutationOptions } = options
		? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey } };

	const mutationFn: MutationFunction<Awaited<ReturnType<typeof refresh>>, void> = () => {
		return refresh();
	};

	return { mutationFn, ...mutationOptions };
};

export type RefreshMutationResult = NonNullable<Awaited<ReturnType<typeof refresh>>>;

export type RefreshMutationError = ErrorType<InternalErrorResponse>;

export const createRefresh = <TError = ErrorType<InternalErrorResponse>, TContext = unknown>(
	options?: () => {
		mutation?: CreateMutationOptions<Awaited<ReturnType<typeof refresh>>, TError, void, TContext>;
	},
	queryClient?: () => QueryClient
): CreateMutationResult<Awaited<ReturnType<typeof refresh>>, TError, void, TContext> => {
	return createMutation(() => ({ ...getRefreshMutationOptions(options?.()) }), queryClient);
};
export type passkeyResponse200 = {
	data: string;
	status: 200;
};

export type passkeyResponse500 = {
	data: InternalErrorResponse;
	status: 500;
};

export type passkeyResponseSuccess = passkeyResponse200 & {
	headers: Headers;
};
export type passkeyResponseError = passkeyResponse500 & {
	headers: Headers;
};

export type passkeyResponse = passkeyResponseSuccess | passkeyResponseError;

export const getPasskeyUrl = () => {
	return `/account/passkey`;
};

export const passkey = async (
	request: Request,
	options?: RequestInit
): Promise<passkeyResponse> => {
	return customInstance<passkeyResponse>(getPasskeyUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(request),
	});
};

export const getPasskeyMutationOptions = <
	TError = ErrorType<InternalErrorResponse>,
	TContext = unknown,
>(options?: {
	mutation?: CreateMutationOptions<
		Awaited<ReturnType<typeof passkey>>,
		TError,
		{ data: BodyType<Request> },
		TContext
	>;
}): CreateMutationOptions<
	Awaited<ReturnType<typeof passkey>>,
	TError,
	{ data: BodyType<Request> },
	TContext
> => {
	const mutationKey = ["passkey"];
	const { mutation: mutationOptions } = options
		? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey } };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof passkey>>,
		{ data: BodyType<Request> }
	> = (props) => {
		const { data } = props ?? {};

		return passkey(data);
	};

	return { mutationFn, ...mutationOptions };
};

export type PasskeyMutationResult = NonNullable<Awaited<ReturnType<typeof passkey>>>;
export type PasskeyMutationBody = BodyType<Request>;
export type PasskeyMutationError = ErrorType<InternalErrorResponse>;

export const createPasskey = <TError = ErrorType<InternalErrorResponse>, TContext = unknown>(
	options?: () => {
		mutation?: CreateMutationOptions<
			Awaited<ReturnType<typeof passkey>>,
			TError,
			{ data: BodyType<Request> },
			TContext
		>;
	},
	queryClient?: () => QueryClient
): CreateMutationResult<
	Awaited<ReturnType<typeof passkey>>,
	TError,
	{ data: BodyType<Request> },
	TContext
> => {
	return createMutation(() => ({ ...getPasskeyMutationOptions(options?.()) }), queryClient);
};
export type accountMeResponse200 = {
	data: UserModel;
	status: 200;
};

export type accountMeResponse401 = {
	data: void;
	status: 401;
};

export type accountMeResponse500 = {
	data: InternalErrorResponse;
	status: 500;
};

export type accountMeResponseSuccess = accountMeResponse200 & {
	headers: Headers;
};
export type accountMeResponseError = (accountMeResponse401 | accountMeResponse500) & {
	headers: Headers;
};

export type accountMeResponse = accountMeResponseSuccess | accountMeResponseError;

export const getAccountMeUrl = () => {
	return `/account/me`;
};

export const accountMe = async (options?: RequestInit): Promise<accountMeResponse> => {
	return customInstance<accountMeResponse>(getAccountMeUrl(), {
		...options,
		method: "GET",
	});
};

export const getAccountMeQueryKey = () => {
	return [`/account/me`] as const;
};

export const getAccountMeQueryOptions = <
	TData = Awaited<ReturnType<typeof accountMe>>,
	TError = ErrorType<void | InternalErrorResponse>,
>(options?: {
	query?: Partial<CreateQueryOptions<Awaited<ReturnType<typeof accountMe>>, TError, TData>>;
}) => {
	const { query: queryOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getAccountMeQueryKey();

	const queryFn: QueryFunction<Awaited<ReturnType<typeof accountMe>>> = () => accountMe();

	return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
		Awaited<ReturnType<typeof accountMe>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AccountMeQueryResult = NonNullable<Awaited<ReturnType<typeof accountMe>>>;
export type AccountMeQueryError = ErrorType<void | InternalErrorResponse>;

export function createAccountMe<
	TData = Awaited<ReturnType<typeof accountMe>>,
	TError = ErrorType<void | InternalErrorResponse>,
>(
	options?: () => {
		query?: Partial<CreateQueryOptions<Awaited<ReturnType<typeof accountMe>>, TError, TData>>;
	},
	queryClient?: () => QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
	const query = createQuery(
		() => getAccountMeQueryOptions(options?.()),
		queryClient
	) as CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

	return query;
}

export type logoutResponse200 = {
	data: boolean;
	status: 200;
};

export type logoutResponse500 = {
	data: InternalErrorResponse;
	status: 500;
};

export type logoutResponseSuccess = logoutResponse200 & {
	headers: Headers;
};
export type logoutResponseError = logoutResponse500 & {
	headers: Headers;
};

export type logoutResponse = logoutResponseSuccess | logoutResponseError;

export const getLogoutUrl = () => {
	return `/account/logout`;
};

export const logout = async (options?: RequestInit): Promise<logoutResponse> => {
	return customInstance<logoutResponse>(getLogoutUrl(), {
		...options,
		method: "POST",
	});
};

export const getLogoutMutationOptions = <
	TError = ErrorType<InternalErrorResponse>,
	TContext = unknown,
>(options?: {
	mutation?: CreateMutationOptions<Awaited<ReturnType<typeof logout>>, TError, void, TContext>;
}): CreateMutationOptions<Awaited<ReturnType<typeof logout>>, TError, void, TContext> => {
	const mutationKey = ["logout"];
	const { mutation: mutationOptions } = options
		? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey } };

	const mutationFn: MutationFunction<Awaited<ReturnType<typeof logout>>, void> = () => {
		return logout();
	};

	return { mutationFn, ...mutationOptions };
};

export type LogoutMutationResult = NonNullable<Awaited<ReturnType<typeof logout>>>;

export type LogoutMutationError = ErrorType<InternalErrorResponse>;

export const createLogout = <TError = ErrorType<InternalErrorResponse>, TContext = unknown>(
	options?: () => {
		mutation?: CreateMutationOptions<Awaited<ReturnType<typeof logout>>, TError, void, TContext>;
	},
	queryClient?: () => QueryClient
): CreateMutationResult<Awaited<ReturnType<typeof logout>>, TError, void, TContext> => {
	return createMutation(() => ({ ...getLogoutMutationOptions(options?.()) }), queryClient);
};
export type loginResponse200 = {
	data: boolean;
	status: 200;
};

export type loginResponse500 = {
	data: InternalErrorResponse;
	status: 500;
};

export type loginResponseSuccess = loginResponse200 & {
	headers: Headers;
};
export type loginResponseError = loginResponse500 & {
	headers: Headers;
};

export type loginResponse = loginResponseSuccess | loginResponseError;

export const getLoginUrl = () => {
	return `/account/login`;
};

export const login = async (
	loginRequest: LoginRequest,
	options?: RequestInit
): Promise<loginResponse> => {
	return customInstance<loginResponse>(getLoginUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(loginRequest),
	});
};

export const getLoginMutationOptions = <
	TError = ErrorType<InternalErrorResponse>,
	TContext = unknown,
>(options?: {
	mutation?: CreateMutationOptions<
		Awaited<ReturnType<typeof login>>,
		TError,
		{ data: BodyType<LoginRequest> },
		TContext
	>;
}): CreateMutationOptions<
	Awaited<ReturnType<typeof login>>,
	TError,
	{ data: BodyType<LoginRequest> },
	TContext
> => {
	const mutationKey = ["login"];
	const { mutation: mutationOptions } = options
		? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey } };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof login>>,
		{ data: BodyType<LoginRequest> }
	> = (props) => {
		const { data } = props ?? {};

		return login(data);
	};

	return { mutationFn, ...mutationOptions };
};

export type LoginMutationResult = NonNullable<Awaited<ReturnType<typeof login>>>;
export type LoginMutationBody = BodyType<LoginRequest>;
export type LoginMutationError = ErrorType<InternalErrorResponse>;

export const createLogin = <TError = ErrorType<InternalErrorResponse>, TContext = unknown>(
	options?: () => {
		mutation?: CreateMutationOptions<
			Awaited<ReturnType<typeof login>>,
			TError,
			{ data: BodyType<LoginRequest> },
			TContext
		>;
	},
	queryClient?: () => QueryClient
): CreateMutationResult<
	Awaited<ReturnType<typeof login>>,
	TError,
	{ data: BodyType<LoginRequest> },
	TContext
> => {
	return createMutation(() => ({ ...getLoginMutationOptions(options?.()) }), queryClient);
};
export type onlineFeaturesAccountLoginGoogleEndpointResponse204 = {
	data: void;
	status: 204;
};

export type onlineFeaturesAccountLoginGoogleEndpointResponse500 = {
	data: InternalErrorResponse;
	status: 500;
};

export type onlineFeaturesAccountLoginGoogleEndpointResponseSuccess =
	onlineFeaturesAccountLoginGoogleEndpointResponse204 & {
		headers: Headers;
	};
export type onlineFeaturesAccountLoginGoogleEndpointResponseError =
	onlineFeaturesAccountLoginGoogleEndpointResponse500 & {
		headers: Headers;
	};

export type onlineFeaturesAccountLoginGoogleEndpointResponse =
	| onlineFeaturesAccountLoginGoogleEndpointResponseSuccess
	| onlineFeaturesAccountLoginGoogleEndpointResponseError;

export const getOnlineFeaturesAccountLoginGoogleEndpointUrl = (
	params: OnlineFeaturesAccountLoginGoogleEndpointParams
) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `/account/login/google?${stringifiedParams}`
		: `/account/login/google`;
};

export const onlineFeaturesAccountLoginGoogleEndpoint = async (
	params: OnlineFeaturesAccountLoginGoogleEndpointParams,
	options?: RequestInit
): Promise<onlineFeaturesAccountLoginGoogleEndpointResponse> => {
	return customInstance<onlineFeaturesAccountLoginGoogleEndpointResponse>(
		getOnlineFeaturesAccountLoginGoogleEndpointUrl(params),
		{
			...options,
			method: "GET",
		}
	);
};

export const getOnlineFeaturesAccountLoginGoogleEndpointQueryKey = (
	params?: OnlineFeaturesAccountLoginGoogleEndpointParams
) => {
	return [`/account/login/google`, ...(params ? [params] : [])] as const;
};

export const getOnlineFeaturesAccountLoginGoogleEndpointQueryOptions = <
	TData = Awaited<ReturnType<typeof onlineFeaturesAccountLoginGoogleEndpoint>>,
	TError = ErrorType<InternalErrorResponse>,
>(
	params: OnlineFeaturesAccountLoginGoogleEndpointParams,
	options?: {
		query?: Partial<
			CreateQueryOptions<
				Awaited<ReturnType<typeof onlineFeaturesAccountLoginGoogleEndpoint>>,
				TError,
				TData
			>
		>;
	}
) => {
	const { query: queryOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getOnlineFeaturesAccountLoginGoogleEndpointQueryKey(params);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof onlineFeaturesAccountLoginGoogleEndpoint>>
	> = () => onlineFeaturesAccountLoginGoogleEndpoint(params);

	return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
		Awaited<ReturnType<typeof onlineFeaturesAccountLoginGoogleEndpoint>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type OnlineFeaturesAccountLoginGoogleEndpointQueryResult = NonNullable<
	Awaited<ReturnType<typeof onlineFeaturesAccountLoginGoogleEndpoint>>
>;
export type OnlineFeaturesAccountLoginGoogleEndpointQueryError = ErrorType<InternalErrorResponse>;

export function createOnlineFeaturesAccountLoginGoogleEndpoint<
	TData = Awaited<ReturnType<typeof onlineFeaturesAccountLoginGoogleEndpoint>>,
	TError = ErrorType<InternalErrorResponse>,
>(
	params: () => OnlineFeaturesAccountLoginGoogleEndpointParams,
	options?: () => {
		query?: Partial<
			CreateQueryOptions<
				Awaited<ReturnType<typeof onlineFeaturesAccountLoginGoogleEndpoint>>,
				TError,
				TData
			>
		>;
	},
	queryClient?: () => QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
	const query = createQuery(
		() => getOnlineFeaturesAccountLoginGoogleEndpointQueryOptions(params(), options?.()),
		queryClient
	) as CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

	return query;
}
